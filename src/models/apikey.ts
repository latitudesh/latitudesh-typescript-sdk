/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const ApiKeyType = {
  ApiKeys: "api_keys",
} as const;
export type ApiKeyType = ClosedEnum<typeof ApiKeyType>;

/**
 * The owner of the API Key
 */
export type ApiKeyUser = {
  id?: string | undefined;
  email?: string | undefined;
};

export type ApiKeyAttributes = {
  /**
   * Name of the API Key
   */
  name?: string | undefined;
  /**
   * The API version associated with this API Key
   */
  apiVersion?: string | undefined;
  /**
   * The last 5 characters of the token created for this API Key
   */
  tokenLastSlice?: string | undefined;
  /**
   * The last time a request was made to the API using this API Key
   */
  lastUsedAt?: Date | undefined;
  /**
   * The owner of the API Key
   */
  user?: ApiKeyUser | undefined;
  /**
   * The time when the API Key was created
   */
  createdAt?: Date | undefined;
  /**
   * The time when the API Key was updated
   */
  updatedAt?: Date | undefined;
  /**
   * Whether the API Key is read-only. Read-only keys can only perform GET, HEAD, and OPTIONS requests. Any POST, PUT, PATCH, or DELETE requests will return a 403 error.
   */
  readOnly?: boolean | undefined;
  /**
   * List of allowed IP addresses or CIDR ranges. If set, the API key can only be used from these IP addresses. Supports both IPv4 and IPv6 addresses.
   */
  allowedIps?: Array<string> | undefined;
};

export type ApiKey = {
  id?: string | undefined;
  type?: ApiKeyType | undefined;
  attributes?: ApiKeyAttributes | undefined;
};

/** @internal */
export const ApiKeyType$inboundSchema: z.ZodNativeEnum<typeof ApiKeyType> = z
  .nativeEnum(ApiKeyType);
/** @internal */
export const ApiKeyType$outboundSchema: z.ZodNativeEnum<typeof ApiKeyType> =
  ApiKeyType$inboundSchema;

/** @internal */
export const ApiKeyUser$inboundSchema: z.ZodType<
  ApiKeyUser,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  email: z.string().optional(),
});
/** @internal */
export type ApiKeyUser$Outbound = {
  id?: string | undefined;
  email?: string | undefined;
};

/** @internal */
export const ApiKeyUser$outboundSchema: z.ZodType<
  ApiKeyUser$Outbound,
  z.ZodTypeDef,
  ApiKeyUser
> = z.object({
  id: z.string().optional(),
  email: z.string().optional(),
});

export function apiKeyUserToJSON(apiKeyUser: ApiKeyUser): string {
  return JSON.stringify(ApiKeyUser$outboundSchema.parse(apiKeyUser));
}
export function apiKeyUserFromJSON(
  jsonString: string,
): SafeParseResult<ApiKeyUser, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ApiKeyUser$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ApiKeyUser' from JSON`,
  );
}

/** @internal */
export const ApiKeyAttributes$inboundSchema: z.ZodType<
  ApiKeyAttributes,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  api_version: z.string().optional(),
  token_last_slice: z.string().optional(),
  last_used_at: z.string().datetime({ offset: true }).transform(v =>
    new Date(v)
  ).optional(),
  user: z.lazy(() => ApiKeyUser$inboundSchema).optional(),
  created_at: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  updated_at: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  read_only: z.boolean().optional(),
  allowed_ips: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "api_version": "apiVersion",
    "token_last_slice": "tokenLastSlice",
    "last_used_at": "lastUsedAt",
    "created_at": "createdAt",
    "updated_at": "updatedAt",
    "read_only": "readOnly",
    "allowed_ips": "allowedIps",
  });
});
/** @internal */
export type ApiKeyAttributes$Outbound = {
  name?: string | undefined;
  api_version?: string | undefined;
  token_last_slice?: string | undefined;
  last_used_at?: string | undefined;
  user?: ApiKeyUser$Outbound | undefined;
  created_at?: string | undefined;
  updated_at?: string | undefined;
  read_only?: boolean | undefined;
  allowed_ips?: Array<string> | undefined;
};

/** @internal */
export const ApiKeyAttributes$outboundSchema: z.ZodType<
  ApiKeyAttributes$Outbound,
  z.ZodTypeDef,
  ApiKeyAttributes
> = z.object({
  name: z.string().optional(),
  apiVersion: z.string().optional(),
  tokenLastSlice: z.string().optional(),
  lastUsedAt: z.date().transform(v => v.toISOString()).optional(),
  user: z.lazy(() => ApiKeyUser$outboundSchema).optional(),
  createdAt: z.date().transform(v => v.toISOString()).optional(),
  updatedAt: z.date().transform(v => v.toISOString()).optional(),
  readOnly: z.boolean().optional(),
  allowedIps: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    apiVersion: "api_version",
    tokenLastSlice: "token_last_slice",
    lastUsedAt: "last_used_at",
    createdAt: "created_at",
    updatedAt: "updated_at",
    readOnly: "read_only",
    allowedIps: "allowed_ips",
  });
});

export function apiKeyAttributesToJSON(
  apiKeyAttributes: ApiKeyAttributes,
): string {
  return JSON.stringify(
    ApiKeyAttributes$outboundSchema.parse(apiKeyAttributes),
  );
}
export function apiKeyAttributesFromJSON(
  jsonString: string,
): SafeParseResult<ApiKeyAttributes, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ApiKeyAttributes$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ApiKeyAttributes' from JSON`,
  );
}

/** @internal */
export const ApiKey$inboundSchema: z.ZodType<ApiKey, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string().optional(),
    type: ApiKeyType$inboundSchema.optional(),
    attributes: z.lazy(() => ApiKeyAttributes$inboundSchema).optional(),
  });
/** @internal */
export type ApiKey$Outbound = {
  id?: string | undefined;
  type?: string | undefined;
  attributes?: ApiKeyAttributes$Outbound | undefined;
};

/** @internal */
export const ApiKey$outboundSchema: z.ZodType<
  ApiKey$Outbound,
  z.ZodTypeDef,
  ApiKey
> = z.object({
  id: z.string().optional(),
  type: ApiKeyType$outboundSchema.optional(),
  attributes: z.lazy(() => ApiKeyAttributes$outboundSchema).optional(),
});

export function apiKeyToJSON(apiKey: ApiKey): string {
  return JSON.stringify(ApiKey$outboundSchema.parse(apiKey));
}
export function apiKeyFromJSON(
  jsonString: string,
): SafeParseResult<ApiKey, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ApiKey$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ApiKey' from JSON`,
  );
}
