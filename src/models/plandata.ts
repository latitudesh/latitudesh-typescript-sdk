/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const TypePlans = {
  Plans: "plans",
} as const;
export type TypePlans = ClosedEnum<typeof TypePlans>;

export const Feature = {
  Ssh: "ssh",
  Raid: "raid",
  UserData: "user_data",
  Sev: "sev",
} as const;
export type Feature = ClosedEnum<typeof Feature>;

export type Cpu = {
  type?: string | undefined;
  clock?: number | undefined;
  cores?: number | undefined;
  count?: number | undefined;
};

export type Memory = {
  total?: number | undefined;
};

export const DriveType = {
  Ssd: "SSD",
  Hdd: "HDD",
  Nvme: "NVME",
} as const;
export type DriveType = ClosedEnum<typeof DriveType>;

export type Drive = {
  count?: number | undefined;
  size?: string | undefined;
  type?: DriveType | undefined;
};

export type PlanDataNic = {
  count?: number | undefined;
  type?: string | undefined;
};

export type Gpu = {
  count?: number | undefined;
  type?: string | undefined;
  /**
   * VRAM per GPU in GB
   */
  vramPerGpu?: number | null | undefined;
  /**
   * GPU interconnection type (e.g., NVLink, PCIe)
   */
  interconnect?: string | null | undefined;
};

export type PlanDataSpecs = {
  cpu?: Cpu | undefined;
  memory?: Memory | undefined;
  drives?: Array<Drive> | undefined;
  nics?: Array<PlanDataNic> | undefined;
  gpu?: Gpu | undefined;
};

export type PlanDataLocations = {
  available?: Array<string> | undefined;
  inStock?: Array<string> | undefined;
};

export const PlanDataStockLevel = {
  Unavailable: "unavailable",
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
export type PlanDataStockLevel = ClosedEnum<typeof PlanDataStockLevel>;

export type PlanDataUSD = {
  hour?: number | null | undefined;
  month?: number | null | undefined;
  year?: number | null | undefined;
};

export type PlanDataBRL = {
  hour?: number | null | undefined;
  month?: number | null | undefined;
  year?: number | null | undefined;
};

export type PlanDataPricing = {
  usd?: PlanDataUSD | undefined;
  brl?: PlanDataBRL | undefined;
};

export type PlanDataRegion = {
  name?: string | undefined;
  deploysInstantly?: Array<string> | undefined;
  locations?: PlanDataLocations | undefined;
  stockLevel?: PlanDataStockLevel | undefined;
  pricing?: PlanDataPricing | undefined;
};

export type PlanDataAttributes = {
  slug?: string | undefined;
  name?: string | undefined;
  /**
   * List of available features for the plan
   */
  features?: Array<Feature> | undefined;
  specs?: PlanDataSpecs | undefined;
  regions?: Array<PlanDataRegion> | undefined;
};

export type PlanData = {
  id?: string | undefined;
  type?: TypePlans | undefined;
  attributes?: PlanDataAttributes | undefined;
};

/** @internal */
export const TypePlans$inboundSchema: z.ZodNativeEnum<typeof TypePlans> = z
  .nativeEnum(TypePlans);
/** @internal */
export const TypePlans$outboundSchema: z.ZodNativeEnum<typeof TypePlans> =
  TypePlans$inboundSchema;

/** @internal */
export const Feature$inboundSchema: z.ZodNativeEnum<typeof Feature> = z
  .nativeEnum(Feature);
/** @internal */
export const Feature$outboundSchema: z.ZodNativeEnum<typeof Feature> =
  Feature$inboundSchema;

/** @internal */
export const Cpu$inboundSchema: z.ZodType<Cpu, z.ZodTypeDef, unknown> = z
  .object({
    type: z.string().optional(),
    clock: z.number().optional(),
    cores: z.number().optional(),
    count: z.number().optional(),
  });
/** @internal */
export type Cpu$Outbound = {
  type?: string | undefined;
  clock?: number | undefined;
  cores?: number | undefined;
  count?: number | undefined;
};

/** @internal */
export const Cpu$outboundSchema: z.ZodType<Cpu$Outbound, z.ZodTypeDef, Cpu> = z
  .object({
    type: z.string().optional(),
    clock: z.number().optional(),
    cores: z.number().optional(),
    count: z.number().optional(),
  });

export function cpuToJSON(cpu: Cpu): string {
  return JSON.stringify(Cpu$outboundSchema.parse(cpu));
}
export function cpuFromJSON(
  jsonString: string,
): SafeParseResult<Cpu, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Cpu$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Cpu' from JSON`,
  );
}

/** @internal */
export const Memory$inboundSchema: z.ZodType<Memory, z.ZodTypeDef, unknown> = z
  .object({
    total: z.number().optional(),
  });
/** @internal */
export type Memory$Outbound = {
  total?: number | undefined;
};

/** @internal */
export const Memory$outboundSchema: z.ZodType<
  Memory$Outbound,
  z.ZodTypeDef,
  Memory
> = z.object({
  total: z.number().optional(),
});

export function memoryToJSON(memory: Memory): string {
  return JSON.stringify(Memory$outboundSchema.parse(memory));
}
export function memoryFromJSON(
  jsonString: string,
): SafeParseResult<Memory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Memory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Memory' from JSON`,
  );
}

/** @internal */
export const DriveType$inboundSchema: z.ZodNativeEnum<typeof DriveType> = z
  .nativeEnum(DriveType);
/** @internal */
export const DriveType$outboundSchema: z.ZodNativeEnum<typeof DriveType> =
  DriveType$inboundSchema;

/** @internal */
export const Drive$inboundSchema: z.ZodType<Drive, z.ZodTypeDef, unknown> = z
  .object({
    count: z.number().optional(),
    size: z.string().optional(),
    type: DriveType$inboundSchema.optional(),
  });
/** @internal */
export type Drive$Outbound = {
  count?: number | undefined;
  size?: string | undefined;
  type?: string | undefined;
};

/** @internal */
export const Drive$outboundSchema: z.ZodType<
  Drive$Outbound,
  z.ZodTypeDef,
  Drive
> = z.object({
  count: z.number().optional(),
  size: z.string().optional(),
  type: DriveType$outboundSchema.optional(),
});

export function driveToJSON(drive: Drive): string {
  return JSON.stringify(Drive$outboundSchema.parse(drive));
}
export function driveFromJSON(
  jsonString: string,
): SafeParseResult<Drive, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Drive$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Drive' from JSON`,
  );
}

/** @internal */
export const PlanDataNic$inboundSchema: z.ZodType<
  PlanDataNic,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().optional(),
  type: z.string().optional(),
});
/** @internal */
export type PlanDataNic$Outbound = {
  count?: number | undefined;
  type?: string | undefined;
};

/** @internal */
export const PlanDataNic$outboundSchema: z.ZodType<
  PlanDataNic$Outbound,
  z.ZodTypeDef,
  PlanDataNic
> = z.object({
  count: z.number().optional(),
  type: z.string().optional(),
});

export function planDataNicToJSON(planDataNic: PlanDataNic): string {
  return JSON.stringify(PlanDataNic$outboundSchema.parse(planDataNic));
}
export function planDataNicFromJSON(
  jsonString: string,
): SafeParseResult<PlanDataNic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanDataNic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanDataNic' from JSON`,
  );
}

/** @internal */
export const Gpu$inboundSchema: z.ZodType<Gpu, z.ZodTypeDef, unknown> = z
  .object({
    count: z.number().optional(),
    type: z.string().optional(),
    vram_per_gpu: z.nullable(z.number()).optional(),
    interconnect: z.nullable(z.string()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "vram_per_gpu": "vramPerGpu",
    });
  });
/** @internal */
export type Gpu$Outbound = {
  count?: number | undefined;
  type?: string | undefined;
  vram_per_gpu?: number | null | undefined;
  interconnect?: string | null | undefined;
};

/** @internal */
export const Gpu$outboundSchema: z.ZodType<Gpu$Outbound, z.ZodTypeDef, Gpu> = z
  .object({
    count: z.number().optional(),
    type: z.string().optional(),
    vramPerGpu: z.nullable(z.number()).optional(),
    interconnect: z.nullable(z.string()).optional(),
  }).transform((v) => {
    return remap$(v, {
      vramPerGpu: "vram_per_gpu",
    });
  });

export function gpuToJSON(gpu: Gpu): string {
  return JSON.stringify(Gpu$outboundSchema.parse(gpu));
}
export function gpuFromJSON(
  jsonString: string,
): SafeParseResult<Gpu, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Gpu$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Gpu' from JSON`,
  );
}

/** @internal */
export const PlanDataSpecs$inboundSchema: z.ZodType<
  PlanDataSpecs,
  z.ZodTypeDef,
  unknown
> = z.object({
  cpu: z.lazy(() => Cpu$inboundSchema).optional(),
  memory: z.lazy(() => Memory$inboundSchema).optional(),
  drives: z.array(z.lazy(() => Drive$inboundSchema)).optional(),
  nics: z.array(z.lazy(() => PlanDataNic$inboundSchema)).optional(),
  gpu: z.lazy(() => Gpu$inboundSchema).optional(),
});
/** @internal */
export type PlanDataSpecs$Outbound = {
  cpu?: Cpu$Outbound | undefined;
  memory?: Memory$Outbound | undefined;
  drives?: Array<Drive$Outbound> | undefined;
  nics?: Array<PlanDataNic$Outbound> | undefined;
  gpu?: Gpu$Outbound | undefined;
};

/** @internal */
export const PlanDataSpecs$outboundSchema: z.ZodType<
  PlanDataSpecs$Outbound,
  z.ZodTypeDef,
  PlanDataSpecs
> = z.object({
  cpu: z.lazy(() => Cpu$outboundSchema).optional(),
  memory: z.lazy(() => Memory$outboundSchema).optional(),
  drives: z.array(z.lazy(() => Drive$outboundSchema)).optional(),
  nics: z.array(z.lazy(() => PlanDataNic$outboundSchema)).optional(),
  gpu: z.lazy(() => Gpu$outboundSchema).optional(),
});

export function planDataSpecsToJSON(planDataSpecs: PlanDataSpecs): string {
  return JSON.stringify(PlanDataSpecs$outboundSchema.parse(planDataSpecs));
}
export function planDataSpecsFromJSON(
  jsonString: string,
): SafeParseResult<PlanDataSpecs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanDataSpecs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanDataSpecs' from JSON`,
  );
}

/** @internal */
export const PlanDataLocations$inboundSchema: z.ZodType<
  PlanDataLocations,
  z.ZodTypeDef,
  unknown
> = z.object({
  available: z.array(z.string()).optional(),
  in_stock: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "in_stock": "inStock",
  });
});
/** @internal */
export type PlanDataLocations$Outbound = {
  available?: Array<string> | undefined;
  in_stock?: Array<string> | undefined;
};

/** @internal */
export const PlanDataLocations$outboundSchema: z.ZodType<
  PlanDataLocations$Outbound,
  z.ZodTypeDef,
  PlanDataLocations
> = z.object({
  available: z.array(z.string()).optional(),
  inStock: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    inStock: "in_stock",
  });
});

export function planDataLocationsToJSON(
  planDataLocations: PlanDataLocations,
): string {
  return JSON.stringify(
    PlanDataLocations$outboundSchema.parse(planDataLocations),
  );
}
export function planDataLocationsFromJSON(
  jsonString: string,
): SafeParseResult<PlanDataLocations, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanDataLocations$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanDataLocations' from JSON`,
  );
}

/** @internal */
export const PlanDataStockLevel$inboundSchema: z.ZodNativeEnum<
  typeof PlanDataStockLevel
> = z.nativeEnum(PlanDataStockLevel);
/** @internal */
export const PlanDataStockLevel$outboundSchema: z.ZodNativeEnum<
  typeof PlanDataStockLevel
> = PlanDataStockLevel$inboundSchema;

/** @internal */
export const PlanDataUSD$inboundSchema: z.ZodType<
  PlanDataUSD,
  z.ZodTypeDef,
  unknown
> = z.object({
  hour: z.nullable(z.number()).optional(),
  month: z.nullable(z.number()).optional(),
  year: z.nullable(z.number()).optional(),
});
/** @internal */
export type PlanDataUSD$Outbound = {
  hour?: number | null | undefined;
  month?: number | null | undefined;
  year?: number | null | undefined;
};

/** @internal */
export const PlanDataUSD$outboundSchema: z.ZodType<
  PlanDataUSD$Outbound,
  z.ZodTypeDef,
  PlanDataUSD
> = z.object({
  hour: z.nullable(z.number()).optional(),
  month: z.nullable(z.number()).optional(),
  year: z.nullable(z.number()).optional(),
});

export function planDataUSDToJSON(planDataUSD: PlanDataUSD): string {
  return JSON.stringify(PlanDataUSD$outboundSchema.parse(planDataUSD));
}
export function planDataUSDFromJSON(
  jsonString: string,
): SafeParseResult<PlanDataUSD, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanDataUSD$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanDataUSD' from JSON`,
  );
}

/** @internal */
export const PlanDataBRL$inboundSchema: z.ZodType<
  PlanDataBRL,
  z.ZodTypeDef,
  unknown
> = z.object({
  hour: z.nullable(z.number()).optional(),
  month: z.nullable(z.number()).optional(),
  year: z.nullable(z.number()).optional(),
});
/** @internal */
export type PlanDataBRL$Outbound = {
  hour?: number | null | undefined;
  month?: number | null | undefined;
  year?: number | null | undefined;
};

/** @internal */
export const PlanDataBRL$outboundSchema: z.ZodType<
  PlanDataBRL$Outbound,
  z.ZodTypeDef,
  PlanDataBRL
> = z.object({
  hour: z.nullable(z.number()).optional(),
  month: z.nullable(z.number()).optional(),
  year: z.nullable(z.number()).optional(),
});

export function planDataBRLToJSON(planDataBRL: PlanDataBRL): string {
  return JSON.stringify(PlanDataBRL$outboundSchema.parse(planDataBRL));
}
export function planDataBRLFromJSON(
  jsonString: string,
): SafeParseResult<PlanDataBRL, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanDataBRL$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanDataBRL' from JSON`,
  );
}

/** @internal */
export const PlanDataPricing$inboundSchema: z.ZodType<
  PlanDataPricing,
  z.ZodTypeDef,
  unknown
> = z.object({
  USD: z.lazy(() => PlanDataUSD$inboundSchema).optional(),
  BRL: z.lazy(() => PlanDataBRL$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "USD": "usd",
    "BRL": "brl",
  });
});
/** @internal */
export type PlanDataPricing$Outbound = {
  USD?: PlanDataUSD$Outbound | undefined;
  BRL?: PlanDataBRL$Outbound | undefined;
};

/** @internal */
export const PlanDataPricing$outboundSchema: z.ZodType<
  PlanDataPricing$Outbound,
  z.ZodTypeDef,
  PlanDataPricing
> = z.object({
  usd: z.lazy(() => PlanDataUSD$outboundSchema).optional(),
  brl: z.lazy(() => PlanDataBRL$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    usd: "USD",
    brl: "BRL",
  });
});

export function planDataPricingToJSON(
  planDataPricing: PlanDataPricing,
): string {
  return JSON.stringify(PlanDataPricing$outboundSchema.parse(planDataPricing));
}
export function planDataPricingFromJSON(
  jsonString: string,
): SafeParseResult<PlanDataPricing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanDataPricing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanDataPricing' from JSON`,
  );
}

/** @internal */
export const PlanDataRegion$inboundSchema: z.ZodType<
  PlanDataRegion,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  deploys_instantly: z.array(z.string()).optional(),
  locations: z.lazy(() => PlanDataLocations$inboundSchema).optional(),
  stock_level: PlanDataStockLevel$inboundSchema.optional(),
  pricing: z.lazy(() => PlanDataPricing$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "deploys_instantly": "deploysInstantly",
    "stock_level": "stockLevel",
  });
});
/** @internal */
export type PlanDataRegion$Outbound = {
  name?: string | undefined;
  deploys_instantly?: Array<string> | undefined;
  locations?: PlanDataLocations$Outbound | undefined;
  stock_level?: string | undefined;
  pricing?: PlanDataPricing$Outbound | undefined;
};

/** @internal */
export const PlanDataRegion$outboundSchema: z.ZodType<
  PlanDataRegion$Outbound,
  z.ZodTypeDef,
  PlanDataRegion
> = z.object({
  name: z.string().optional(),
  deploysInstantly: z.array(z.string()).optional(),
  locations: z.lazy(() => PlanDataLocations$outboundSchema).optional(),
  stockLevel: PlanDataStockLevel$outboundSchema.optional(),
  pricing: z.lazy(() => PlanDataPricing$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    deploysInstantly: "deploys_instantly",
    stockLevel: "stock_level",
  });
});

export function planDataRegionToJSON(planDataRegion: PlanDataRegion): string {
  return JSON.stringify(PlanDataRegion$outboundSchema.parse(planDataRegion));
}
export function planDataRegionFromJSON(
  jsonString: string,
): SafeParseResult<PlanDataRegion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanDataRegion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanDataRegion' from JSON`,
  );
}

/** @internal */
export const PlanDataAttributes$inboundSchema: z.ZodType<
  PlanDataAttributes,
  z.ZodTypeDef,
  unknown
> = z.object({
  slug: z.string().optional(),
  name: z.string().optional(),
  features: z.array(Feature$inboundSchema).optional(),
  specs: z.lazy(() => PlanDataSpecs$inboundSchema).optional(),
  regions: z.array(z.lazy(() => PlanDataRegion$inboundSchema)).optional(),
});
/** @internal */
export type PlanDataAttributes$Outbound = {
  slug?: string | undefined;
  name?: string | undefined;
  features?: Array<string> | undefined;
  specs?: PlanDataSpecs$Outbound | undefined;
  regions?: Array<PlanDataRegion$Outbound> | undefined;
};

/** @internal */
export const PlanDataAttributes$outboundSchema: z.ZodType<
  PlanDataAttributes$Outbound,
  z.ZodTypeDef,
  PlanDataAttributes
> = z.object({
  slug: z.string().optional(),
  name: z.string().optional(),
  features: z.array(Feature$outboundSchema).optional(),
  specs: z.lazy(() => PlanDataSpecs$outboundSchema).optional(),
  regions: z.array(z.lazy(() => PlanDataRegion$outboundSchema)).optional(),
});

export function planDataAttributesToJSON(
  planDataAttributes: PlanDataAttributes,
): string {
  return JSON.stringify(
    PlanDataAttributes$outboundSchema.parse(planDataAttributes),
  );
}
export function planDataAttributesFromJSON(
  jsonString: string,
): SafeParseResult<PlanDataAttributes, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanDataAttributes$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanDataAttributes' from JSON`,
  );
}

/** @internal */
export const PlanData$inboundSchema: z.ZodType<
  PlanData,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: TypePlans$inboundSchema.optional(),
  attributes: z.lazy(() => PlanDataAttributes$inboundSchema).optional(),
});
/** @internal */
export type PlanData$Outbound = {
  id?: string | undefined;
  type?: string | undefined;
  attributes?: PlanDataAttributes$Outbound | undefined;
};

/** @internal */
export const PlanData$outboundSchema: z.ZodType<
  PlanData$Outbound,
  z.ZodTypeDef,
  PlanData
> = z.object({
  id: z.string().optional(),
  type: TypePlans$outboundSchema.optional(),
  attributes: z.lazy(() => PlanDataAttributes$outboundSchema).optional(),
});

export function planDataToJSON(planData: PlanData): string {
  return JSON.stringify(PlanData$outboundSchema.parse(planData));
}
export function planDataFromJSON(
  jsonString: string,
): SafeParseResult<PlanData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlanData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlanData' from JSON`,
  );
}
